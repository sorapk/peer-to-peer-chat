{"version":3,"sources":["PeerInfo.tsx","Connection.tsx","Room.tsx","App.js","index.tsx"],"names":["PeerState","firebase","firestore","auth","initializeApp","Connection","a","str","process","slice","firebaseConfig","JSON","parse","db","signInAnonymously","userAuth","user","console","log","uid","collection","doc","get","existingUserRef","exists","id","data","set","authenInfo","friendList","roomOwner","roomMemeber","userRef","firebaseTimeToTimestamp","firebaseTimestamp","seconds","nanoseconds","Timestamp","toMillis","processCallerData","docID","docRef","runTransaction","transaction","connectionInfo","callerPayload","from","lastUpdated","callerMsgInd","callerMsgCnt","currentTime","now","lastUpdateMili","expired","copyPayload","Object","assign","copyMsgInd","update","callerMsgDiff","toDate","processCalleeData","calleePayload","to","calleeMsgInd","calleeMsgCnt","calleeMsgDiff","connectionInterface","userID","onCallerMsg","roomID","message","callback","where","onSnapshot","snapshot","forEach","onCalleeMsg","sendCallerAResponse","connectionID","sort","join","increment","FieldValue","TextEncoder","encode","stringify","length","payloadByteUsed","sendCalleeAResponse","initiateConnection","connectionRef","priorConnectionDoc","priorConData","priorConExpired","controlLastUpdated","0","error","joinRoom","updatedDoc","createRoom","add","created","arrayUnion","res","PeerInfo","state","peer","this","PEER_STATE_0","stream","peerType","onSignal","onEvent","options","initiator","trickle","Peer","on","signal","PEER_STATE_3","__peerCleanUp","err","PEER_STATE_4","destroy","myStream","callerID","payload","PEER_STATE_1","PEER_STATE_2","__initPeer","__peerProcessSignal","calleeID","Video","props","ref","useRef","useEffect","current","srcObject","playsInline","autoPlay","Room","withRouter","userVideoRef","match","params","videoConstraints","height","window","innerHeight","width","innerWidth","connection","userInRoomRef","useState","setUserInRoomState","undefined","navigator","mediaDevices","getUserMedia","video","audio","then","gotMedia","roomInfo","alert","history","push","msg","currentPeerInfo","processCallerPayload","event","processCalleePayload","callPeerInRoom","userInRoom","currentUserID","joinedTimestamp","peerID","timestamp","callPeer","peerList","peerid","stateToColor","failed","initiated","connecting","connected","stat","keys","map","key","style","backgroundColor","muted","index","App","setUserDB","roomPath","setRoomPath","userDB","roomId","basename","StrictMode","onClick","path","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d5d5aa14.chunk.js","sourcesContent":["import SimplePeer from 'simple-peer';\r\nimport Peer from 'simple-peer';\r\n\r\nenum PeerState {\r\n  PEER_STATE_0 = 'not-connected',\r\n  PEER_STATE_1 = 'initiated',\r\n  PEER_STATE_2 = 'connecting',\r\n  PEER_STATE_3 = 'connected',\r\n  PEER_STATE_4 = 'failed',\r\n}\r\nexport class PeerInfo {\r\n  id: string;\r\n  state: PeerState;\r\n  peer: SimplePeer.Instance | null;\r\n\r\n  constructor(id: string) {\r\n    this.id = id;\r\n    this.state = PeerState.PEER_STATE_0;\r\n    this.peer = null;\r\n  }\r\n  __initPeer(\r\n    stream: MediaStream,\r\n    peerType: 'initiator' | 'non-initiator',\r\n    onSignal: (signal: SimplePeer.SignalData) => void,\r\n    onEvent: (event: 'connect' | 'disconnect' | 'error') => void\r\n  ) {\r\n    const options = {\r\n      initiator: peerType === 'initiator',\r\n      trickle: false,\r\n      stream,\r\n    };\r\n    const peer = new Peer(options);\r\n    peer.on('signal', (signal: any) => {\r\n      onSignal(signal);\r\n    });\r\n    peer.on('connect', () => {\r\n      console.log('connection establised:', this.id);\r\n      this.state = PeerState.PEER_STATE_3;\r\n      onEvent('connect');\r\n    });\r\n    peer.on('close', () => {\r\n      this.state = PeerState.PEER_STATE_0;\r\n      console.log('connection closed:', this.id);\r\n      this.__peerCleanUp();\r\n      onEvent('disconnect');\r\n    });\r\n    peer.on('error', (err: any) => {\r\n      console.log('connection error:', this.id, err);\r\n      this.state = PeerState.PEER_STATE_4;\r\n      onEvent('error');\r\n    });\r\n    this.peer = peer;\r\n  }\r\n  __peerProcessSignal(signal: SimplePeer.SignalData) {\r\n    if (this.peer) {\r\n      this.peer.signal(signal);\r\n    }\r\n  }\r\n  __peerCleanUp() {\r\n    if (this.peer) {\r\n      this.peer.destroy();\r\n      this.peer = null;\r\n    }\r\n  }\r\n  // ===================\r\n  processCallerPayload(\r\n    myStream: MediaStream,\r\n    callerID: string,\r\n    payload: any,\r\n    onSignal: (signal: SimplePeer.SignalData) => void,\r\n    onEvent: (event: 'connect' | 'disconnect' | 'error') => void\r\n  ) {\r\n    if (this.state === PeerState.PEER_STATE_0) {\r\n      this.state = PeerState.PEER_STATE_1;\r\n      // initiate call\r\n      console.log('initiation recieved from:', callerID);\r\n    } else if (this.state === PeerState.PEER_STATE_1) {\r\n      this.state = PeerState.PEER_STATE_2;\r\n\r\n      // process offer\r\n      console.log('recieved offer recieved from:', callerID);\r\n      console.log('offer:', payload);\r\n\r\n      this.__initPeer(myStream, 'non-initiator', onSignal, onEvent);\r\n      // process offer\r\n      this.__peerProcessSignal(payload);\r\n    } else if (\r\n      this.state === PeerState.PEER_STATE_2 ||\r\n      this.state === PeerState.PEER_STATE_3\r\n    ) {\r\n      // process ICE\r\n      console.log('recieved ICE recieved from:', callerID);\r\n      console.log('ICE:', payload);\r\n      this.__peerProcessSignal(payload);\r\n    } else {\r\n      // bad state, clean up\r\n      this.state = PeerState.PEER_STATE_4;\r\n      this.__peerCleanUp();\r\n    }\r\n  }\r\n  processCalleePayload(\r\n    myStream: MediaStream,\r\n    calleeID: string,\r\n    payload: any,\r\n    onSignal: (signal: SimplePeer.SignalData) => void,\r\n    onEvent: (event: 'connect' | 'disconnect' | 'error') => void\r\n  ) {\r\n    if (\r\n      //callee accepted\r\n      this.state === PeerState.PEER_STATE_0\r\n    ) {\r\n      this.state = PeerState.PEER_STATE_1;\r\n      // callee accepted, create and send offer to be sent\r\n      console.log('callee accepted call:', calleeID);\r\n      this.__initPeer(myStream, 'initiator', onSignal, onEvent);\r\n    } else if (\r\n      this.state === PeerState.PEER_STATE_1 ||\r\n      this.state === PeerState.PEER_STATE_2 ||\r\n      this.state === PeerState.PEER_STATE_3\r\n    ) {\r\n      //process callee accepted and ICE candidate\r\n      if (this.state === PeerState.PEER_STATE_1) {\r\n        this.state = PeerState.PEER_STATE_2;\r\n      }\r\n      // process offer\r\n      console.log('recieved answer/ICE recieved from callee:', calleeID);\r\n      console.log('callee data:', payload);\r\n      // process offer\r\n      this.__peerProcessSignal(payload);\r\n    } else {\r\n      // bad state, clean up\r\n      this.state = PeerState.PEER_STATE_4;\r\n      this.__peerCleanUp();\r\n    }\r\n  }\r\n}\r\n","import { firestore, auth, initializeApp } from 'firebase';\r\n\r\nconst firebase = { firestore, auth, initializeApp };\r\n\r\nexport const CALLER_MSG_INITIATE = 'initiate';\r\nexport const CALLEE_MSG_ACCEPT = 'callee-accept';\r\n\r\ntype NumberDict = {\r\n  [key: number]: any;\r\n};\r\ntype FirebaseTimeStamp = {\r\n  seconds: any;\r\n  nanoseconds: any;\r\n};\r\ntype ConnectionInfo = {\r\n  from: string;\r\n  to: string;\r\n  roomID: string;\r\n  message: string;\r\n  // =============\r\n  callerMsgCnt: number;\r\n  callerMsgInd: number;\r\n  callerMsgDiff: number;\r\n  callerPayload: NumberDict;\r\n  // ==============\r\n  calleeMsgCnt: number;\r\n  calleeMsgInd: number;\r\n  calleeMsgDiff: number;\r\n  calleePayload: NumberDict;\r\n  // ==============\r\n  payloadByteUsed: number;\r\n  lastUpdated: FirebaseTimeStamp;\r\n};\r\nexport type Connection = {\r\n  userID: () => string;\r\n  onCallerMsg: (roomID: string, message: string, callback: Function) => void;\r\n  onCalleeMsg: (roomID: string, message: string, callback: Function) => void;\r\n  sendCallerAResponse: (data: any, from: string) => Promise<any>;\r\n  sendCalleeAResponse: (data: any, to: string) => Promise<any>;\r\n  initiateConnection: (\r\n    roomID: string,\r\n    message: string,\r\n    to: string\r\n  ) => Promise<any>;\r\n  joinRoom: (roomID: string) => Promise<any>;\r\n  createRoom: () => Promise<null | string>;\r\n  firebaseTimeToTimestamp: (firebaseTimestamp: FirebaseTimeStamp) => number;\r\n};\r\nexport const Connection = async () => {\r\n  if (process.env.REACT_APP_PEER_FIREBASE === undefined) {\r\n    throw 'Firebase API Key Not Defined';\r\n  }\r\n\r\n  const str = process.env.REACT_APP_PEER_FIREBASE.slice(1, -1);\r\n  const firebaseConfig = JSON.parse(str);\r\n  firebase.initializeApp(firebaseConfig);\r\n  const db = firebase.firestore();\r\n  const userAuth = await firebase.auth().signInAnonymously();\r\n\r\n  if (userAuth === null || userAuth.user === null) {\r\n    return;\r\n  }\r\n  console.log('user auth uid:', userAuth.user.uid);\r\n  let existingUserRef = await db\r\n    .collection('user')\r\n    .doc(userAuth.user.uid)\r\n    .get();\r\n  console.log('==== user existing info ====');\r\n  console.log('user has existing info status:', existingUserRef.exists);\r\n  console.log('user existing info id:', existingUserRef.id);\r\n  console.log('user existing info:', existingUserRef.data());\r\n\r\n  if (!(existingUserRef && existingUserRef.exists)) {\r\n    await db.collection('user').doc(userAuth.user.uid).set({\r\n      authenInfo: null,\r\n      friendList: [],\r\n      roomOwner: [],\r\n      roomMemeber: [],\r\n    });\r\n  }\r\n  const userRef = await db.collection('user').doc(userAuth.user.uid);\r\n  console.log('userRef:', userRef);\r\n  console.log('userRef id:', userRef.id);\r\n\r\n  const firebaseTimeToTimestamp = (firebaseTimestamp: FirebaseTimeStamp) => {\r\n    const { seconds, nanoseconds } = firebaseTimestamp;\r\n\r\n    const timestamp = new firebase.firestore.Timestamp(\r\n      seconds,\r\n      nanoseconds\r\n    ).toMillis();\r\n\r\n    return timestamp;\r\n  };\r\n  const processCallerData = async (docID: string) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      let doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        const connectionInfo = doc.data() as ConnectionInfo;\r\n\r\n        const { callerPayload, from, lastUpdated } = connectionInfo;\r\n        let { callerMsgInd, callerMsgCnt } = connectionInfo;\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming caller msg:', {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (callerMsgInd >= callerMsgCnt || expired) {\r\n          console.log('no caller msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, callerPayload);\r\n        const copyMsgInd = callerMsgInd;\r\n\r\n        //process incoming data\r\n        while (callerMsgInd < callerMsgCnt)\r\n          delete callerPayload[callerMsgInd++];\r\n        console.log('updating remote copy:', { callerPayload, callerMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          callerPayload: copyPayload,\r\n          callerMsgInd: copyMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n  const processCalleeData = async (docID: string) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      const doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        const connectionInfo = doc.data() as ConnectionInfo;\r\n        let {\r\n          calleePayload,\r\n          to,\r\n          lastUpdated,\r\n          calleeMsgInd,\r\n          calleeMsgCnt,\r\n        } = connectionInfo;\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming callee msg:', {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (calleeMsgInd >= calleeMsgCnt || expired) {\r\n          console.log('no callee msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, calleePayload);\r\n        const copyMsgInd = calleeMsgInd;\r\n\r\n        //process incoming data\r\n        while (calleeMsgInd < calleeMsgCnt)\r\n          delete calleePayload[calleeMsgInd++];\r\n        console.log('updating remote copy:', { calleePayload, calleeMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          calleePayload: copyPayload,\r\n          calleeMsgInd: copyMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n\r\n  const connectionInterface: Connection = {\r\n    userID: function () {\r\n      return userRef.id;\r\n    },\r\n    onCallerMsg: function (\r\n      roomID: string,\r\n      message: string,\r\n      callback: Function\r\n    ) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('to', '==', userRef.id)\r\n        .where('callerMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCallerData(doc.id);\r\n\r\n              if (data) {\r\n                const {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                  from,\r\n                } = data;\r\n                console.log('processing payload:', {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                });\r\n                await callback(callerPayload, callerMsgInd, callerMsgCnt, from);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    onCalleeMsg: function (\r\n      roomID: string,\r\n      message: string,\r\n      callback: Function\r\n    ) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('from', '==', userRef.id)\r\n        .where('calleeMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCalleeData(doc.id);\r\n\r\n              if (data) {\r\n                const { calleePayload, calleeMsgInd, calleeMsgCnt, to } = data;\r\n\r\n                await callback(calleePayload, calleeMsgInd, calleeMsgCnt, to);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    sendCallerAResponse: async function (data: any, from: string) {\r\n      const connectionID = [from, userRef.id].sort().join('_');\r\n      console.log('responding to caller:', from);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          const connectionInfo = doc.data() as ConnectionInfo;\r\n          let { calleePayload, calleeMsgCnt, calleeMsgInd } = connectionInfo;\r\n\r\n          // get byte count of payload/data\r\n          const increment = firebase.firestore.FieldValue.increment(\r\n            new TextEncoder().encode(JSON.stringify(data)).length\r\n          );\r\n\r\n          calleePayload[calleeMsgCnt] = data;\r\n          calleeMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            calleeMsgCnt,\r\n            calleePayload,\r\n            calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            payloadByteUsed: increment,\r\n          });\r\n        }\r\n      });\r\n    },\r\n    sendCalleeAResponse: async function (data: any, to: string) {\r\n      const connectionID = [to, userRef.id].sort().join('_');\r\n      console.log('responding to callee:', to);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          const connectionInfo = doc.data() as ConnectionInfo;\r\n          let { callerPayload, callerMsgCnt, callerMsgInd } = connectionInfo;\r\n\r\n          // get byte count of payload/data\r\n          const increment = firebase.firestore.FieldValue.increment(\r\n            new TextEncoder().encode(JSON.stringify(data)).length\r\n          );\r\n\r\n          callerPayload[callerMsgCnt] = data;\r\n          callerMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            callerMsgCnt,\r\n            callerPayload,\r\n            callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            payloadByteUsed: increment,\r\n          });\r\n        }\r\n      });\r\n    },\r\n    initiateConnection: async function (\r\n      roomID: string,\r\n      message: string,\r\n      to: string\r\n    ) {\r\n      try {\r\n        const connectionID = [to, userRef.id].sort().join('_');\r\n        console.log('initiating connnection from:', userRef.id);\r\n        console.log('connection id:', connectionID);\r\n        console.log({ roomID, message, to, from: userRef.id });\r\n\r\n        // check if other caller is in control\r\n        const connectionRef = await db.doc(`connection/${connectionID}`);\r\n\r\n        await db.runTransaction(async (transaction) => {\r\n          const priorConnectionDoc = await transaction.get(connectionRef);\r\n\r\n          const priorConData =\r\n            priorConnectionDoc.exists === true\r\n              ? priorConnectionDoc.data()\r\n              : null;\r\n          let priorConExpired = false;\r\n\r\n          if (priorConData) {\r\n            const controlLastUpdated = this.firebaseTimeToTimestamp(\r\n              priorConData.lastUpdated\r\n            );\r\n            const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n            priorConExpired = currentTime - controlLastUpdated >= 30000; //expired after 30 seconds\r\n\r\n            console.log(\r\n              'prior control expire status:',\r\n              priorConExpired,\r\n              ', milisecond elapsed:',\r\n              currentTime - controlLastUpdated\r\n            );\r\n          }\r\n\r\n          if (priorConData === null || priorConExpired) {\r\n            // initiate connection\r\n            console.log('creating new connection');\r\n            await transaction.set(connectionRef, {\r\n              from: userRef.id,\r\n              to,\r\n              roomID,\r\n              message,\r\n              // =============\r\n              callerMsgCnt: 1,\r\n              callerMsgInd: 0,\r\n              callerMsgDiff: 1,\r\n              callerPayload: { 0: CALLER_MSG_INITIATE },\r\n              // ==============\r\n              calleeMsgCnt: 0,\r\n              calleeMsgInd: 0,\r\n              calleeMsgDiff: 0,\r\n              calleePayload: {},\r\n              // ==============\r\n              payloadByteUsed: 0,\r\n              lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            });\r\n          }\r\n        });\r\n      } catch (e) {\r\n        console.error('msg send error:', e);\r\n      }\r\n    },\r\n    joinRoom: async function (roomID: string) {\r\n      try {\r\n        console.log('joining room:', roomID);\r\n        if (roomID) {\r\n          const docRef = await db.doc(`room/${roomID}`);\r\n          const doc = await docRef.get();\r\n\r\n          if (doc && doc.exists) {\r\n            console.log('userRef in room:', userRef.id);\r\n            const user = {\r\n              ['user.' +\r\n              userRef.id]: firebase.firestore.Timestamp.now().toDate(),\r\n            };\r\n            console.log('room data:', doc.data());\r\n            console.log('msg queue data:', user);\r\n            await docRef.update(user);\r\n            const updatedDoc = await docRef.get();\r\n            return updatedDoc.data();\r\n          } else {\r\n            console.log(\"room doesn't exist:\", roomID);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        console.error('join room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    createRoom: async function () {\r\n      try {\r\n        const docRef = await db.collection('room').add({\r\n          user: {},\r\n          created: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n        const res = await userRef.update({\r\n          roomOwner: firebase.firestore.FieldValue.arrayUnion(docRef.id),\r\n        });\r\n        console.log('create room id:', docRef.id);\r\n        console.log('create room info:', res);\r\n        return docRef.id;\r\n      } catch (e) {\r\n        console.error('create room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    firebaseTimeToTimestamp: firebaseTimeToTimestamp,\r\n  };\r\n\r\n  return connectionInterface;\r\n};\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport { withRouter, RouteComponentProps } from 'react-router-dom';\r\nimport {\r\n  Connection,\r\n  CALLEE_MSG_ACCEPT,\r\n  CALLER_MSG_INITIATE,\r\n} from './Connection';\r\nimport SimplePeer from 'simple-peer';\r\n\r\nimport { PeerInfo } from './PeerInfo';\r\n\r\ntype FixLater = any;\r\n\r\nconst Video = (props: { peer: SimplePeer.Instance | null }) => {\r\n  const ref = useRef<FixLater>();\r\n\r\n  useEffect(() => {\r\n    if (props.peer) {\r\n      props.peer.on('stream', (stream: MediaStream) => {\r\n        console.log('peer stream:', stream);\r\n        if (ref.current) {\r\n          ref.current.srcObject = stream;\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <video playsInline autoPlay ref={ref}></video>\r\n    </div>\r\n  );\r\n};\r\ninterface Props extends RouteComponentProps<{ id: string }> {\r\n  connection: Connection;\r\n}\r\ninterface UserInRoom {\r\n  [key: string]: PeerInfo;\r\n}\r\n// reference:\r\n// https://ui.dev/react-router-v4-programmatically-navigate/\r\nexport const Room = withRouter(({ ...props }: Props) => {\r\n  const userVideoRef = useRef<any>();\r\n  const roomID = props.match.params.id;\r\n  const videoConstraints = {\r\n    height: window.innerHeight / 2,\r\n    width: window.innerWidth / 2,\r\n  };\r\n  console.log('roomID-->', roomID, 'props -->', props);\r\n  const connection = props.connection;\r\n\r\n  // ==============\r\n  const userInRoomRef = useRef<UserInRoom>({});\r\n  const [userInRoomState, setUserInRoomState] = useState({});\r\n\r\n  useEffect(() => {\r\n    if (connection === undefined) {\r\n      return;\r\n    }\r\n    navigator.mediaDevices\r\n      .getUserMedia({ video: videoConstraints, audio: false })\r\n      .then(gotMedia);\r\n  }, []);\r\n\r\n  const gotMedia = async (stream: MediaStream) => {\r\n    if (userVideoRef === undefined || userVideoRef.current === undefined) {\r\n      return;\r\n    }\r\n    userVideoRef.current.srcObject = stream;\r\n\r\n    const roomInfo = await connection.joinRoom(roomID);\r\n\r\n    if (roomInfo === null) {\r\n      alert('This room does not exist.');\r\n      props.history.push(`/`);\r\n    }\r\n\r\n    //0. initialize list of user in room\r\n    for (const userID in roomInfo.user) {\r\n      if (userID !== connection.userID()) {\r\n        userInRoomRef.current[userID] = new PeerInfo(userID);\r\n      }\r\n    }\r\n    //1. register listener to incoming request to connect\r\n    connection.onCallerMsg(\r\n      roomID,\r\n      'request-connect',\r\n      async (\r\n        callerPayload: any[],\r\n        callerMsgInd: number,\r\n        callerMsgCnt: number,\r\n        from: string\r\n      ) => {\r\n        while (callerMsgInd < callerMsgCnt) {\r\n          const msg = callerPayload[callerMsgInd++];\r\n\r\n          if (userInRoomRef.current[from] === undefined) {\r\n            userInRoomRef.current[from] = new PeerInfo(from);\r\n          }\r\n\r\n          const currentPeerInfo = userInRoomRef.current[from];\r\n\r\n          if (msg === CALLER_MSG_INITIATE) {\r\n            await connection.sendCallerAResponse(CALLEE_MSG_ACCEPT, from);\r\n          }\r\n          currentPeerInfo.processCallerPayload(\r\n            stream,\r\n            from,\r\n            msg,\r\n            (signal) => {\r\n              //TODO: compress signal data here\r\n              connection.sendCallerAResponse(signal, from);\r\n            },\r\n            (event) => {\r\n              //Update View when PeerToPeer Connection state cahges\r\n              setUserInRoomState({});\r\n            }\r\n          );\r\n        }\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n    //2. register listener to incoming responses from callee\r\n    connection.onCalleeMsg(\r\n      roomID,\r\n      'response-signal',\r\n      async (\r\n        calleePayload: any[],\r\n        calleeMsgInd: number,\r\n        calleeMsgCnt: number,\r\n        to: string\r\n      ) => {\r\n        while (calleeMsgInd < calleeMsgCnt) {\r\n          const msg = calleePayload[calleeMsgInd++];\r\n\r\n          if (userInRoomRef.current[to] === undefined) {\r\n            userInRoomRef.current[to] = new PeerInfo(to);\r\n          }\r\n          const currentPeerInfo = userInRoomRef.current[to];\r\n\r\n          currentPeerInfo.processCalleePayload(\r\n            stream,\r\n            to,\r\n            msg,\r\n            (signal) => {\r\n              connection.sendCalleeAResponse(signal, to);\r\n            },\r\n            (event) => {\r\n              //Update View when PeerToPeer Connection state cahges\r\n              setUserInRoomState({});\r\n            }\r\n          );\r\n        }\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n    //3. call existing peers in room\r\n    callPeerInRoom(stream, roomInfo);\r\n\r\n    setUserInRoomState({});\r\n  };\r\n  const callPeerInRoom = (stream: MediaStream, roomInfo: { user: any }) => {\r\n    //3. call each user in the roo\r\n    console.log({ roomInfo });\r\n    const userInRoom = roomInfo.user;\r\n    const currentUserID = connection.userID();\r\n    const joinedTimestamp = connection.firebaseTimeToTimestamp(\r\n      userInRoom[currentUserID]\r\n    );\r\n    console.log('current user joined room timestamp:', joinedTimestamp);\r\n\r\n    for (const peerID in userInRoom) {\r\n      const timestamp = connection.firebaseTimeToTimestamp(userInRoom[peerID]);\r\n\r\n      // call users that were on before current user\r\n      if (peerID !== currentUserID && timestamp < joinedTimestamp) {\r\n        callPeer(peerID, stream, roomID);\r\n      }\r\n    }\r\n  };\r\n  const callPeer = (peerID: string, stream: any, roomID: string) => {\r\n    connection.initiateConnection(roomID, 'initiate-connection', peerID);\r\n  };\r\n  const peerList = [];\r\n  for (const peerid in userInRoomRef.current) {\r\n    if (userInRoomRef.current[peerid].peer) {\r\n      peerList.push(userInRoomRef.current[peerid].peer);\r\n    }\r\n  }\r\n  const stateToColor = {\r\n    failed: 'red',\r\n    initiated: 'orange',\r\n    'not-connected': 'grey',\r\n    connecting: 'yellow',\r\n    connected: 'green',\r\n  };\r\n\r\n  const stat = !userInRoomRef.current\r\n    ? null\r\n    : Object.keys(userInRoomRef.current).map((key) => {\r\n        return (\r\n          <li key={key}>\r\n            User ID: {key} Status:{' '}\r\n            <span\r\n              style={{\r\n                backgroundColor: stateToColor[userInRoomRef.current[key].state],\r\n              }}\r\n            >\r\n              {userInRoomRef.current[key].state}\r\n            </span>\r\n          </li>\r\n        );\r\n      });\r\n  console.log('peer list:', peerList);\r\n  console.log(userInRoomRef.current);\r\n  return (\r\n    <div>\r\n      <h3>My User ID: {connection ? connection.userID() : undefined}</h3>\r\n      <video muted ref={userVideoRef} autoPlay playsInline></video>\r\n      <h3>User In Room:</h3>\r\n      <ul>{stat}</ul>\r\n      <hr></hr>\r\n      {peerList.map((peer, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {index}\r\n            <Video peer={peer}></Video>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n});\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport { withRouter, Route, Switch, Redirect } from 'react-router-dom';\r\nimport './App.css';\r\nimport Peer from 'simple-peer';\r\nimport { BrowserRouter, HashRouter } from 'react-router-dom';\r\nimport { Connection } from './Connection.tsx';\r\nimport { Room } from './Room';\r\n\r\nconst App = (props) => {\r\n  const [connection, setUserDB] = useState();\r\n  const [roomPath, setRoomPath] = useState(null);\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      const userDB = await Connection();\r\n      setUserDB(userDB);\r\n    })();\r\n  }, []);\r\n\r\n  const createRoom = async () => {\r\n    const roomId = await connection.createRoom();\r\n    setRoomPath(`/room/${roomId}`);\r\n  };\r\n  return (\r\n    <HashRouter basename='/'>\r\n      <React.StrictMode>\r\n        <button onClick={createRoom}>Create Room</button>\r\n        {roomPath ? <Redirect to={roomPath} /> : undefined}\r\n        <Switch>\r\n          <Route\r\n            path='/room/:id'\r\n            component={() => <Room {...props} connection={connection} />}\r\n          ></Route>\r\n        </Switch>\r\n      </React.StrictMode>\r\n    </HashRouter>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}