{"version":3,"sources":["App.js","index.js"],"names":["firebase","firestore","auth","initializeApp","console","log","process","UserDB","a","firebaseConfig","JSON","parse","db","signInAnonymously","userAuth","user","uid","collection","doc","get","existingUserRef","exists","id","data","set","authenInfo","friendList","roomOwner","roomMemeber","userRef","firebaseTimeToTimestamp","firebaseTimestamp","seconds","nanoseconds","Timestamp","toMillis","processCallerData","docID","docRef","runTransaction","transaction","callerPayload","from","lastUpdated","callerMsgInd","callerMsgCnt","currentTime","now","lastUpdateMili","expired","copyPayload","Object","assign","copyMsgInd","update","callerMsgDiff","toDate","processCalleeData","calleePayload","to","calleeMsgInd","calleeMsgCnt","calleeMsgDiff","userID","userInfo","on","roomID","message","callback","onCallerMsg","where","onSnapshot","snapshot","forEach","onCalleeMsg","sendCallerAResponse","connectionID","sort","join","sendCalleeAResponse","initiateConnection","connectionRef","priorConnectionDoc","priorConData","priorConExpired","controlLastUpdated","0","CALLER_MSG_INITIATE","error","emit","respond","sendAndWaitForResponse","payload","timeout","response","msgRead","TIMEOUT_FLAG","unsubListener","isTimedout","responsePromise","Promise","resolve","reject","timeoutPromise","setTimeout","race","result","joinRoom","updatedDoc","createRoom","add","created","FieldValue","arrayUnion","res","PeerInfo","this","state","peer","Video","props","ref","useRef","useEffect","stream","current","srcObject","playsInline","autoPlay","Room","withRouter","userVideoRef","match","params","videoConstraints","height","window","innerHeight","width","innerWidth","userDB","userInRoomRef","useState","userInRoomState","setUserInRoomState","undefined","navigator","mediaDevices","getUserMedia","video","audio","then","gotMedia","roomInfo","alert","history","push","msg","currentPeerInfo","addPeer","signal","destroy","err","createPeer","currentom","callPeerInRoom","userInRoom","currentUserID","joinedTimestamp","peerID","timestamp","callPeer","userToSignal","onSignal","Peer","initiator","trickle","incomingSignal","callerID","peerList","peerid","stateToColor","failed","initiated","connecting","connected","stat","keys","map","key","style","backgroundColor","muted","index","App","setUserDB","roomPath","setRoomPath","roomId","basename","StrictMode","onClick","path","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.cfae2222.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { withRouter, Route, Switch, Redirect } from 'react-router-dom';\r\nimport './App.css';\r\nimport { firestore, auth, initializeApp } from 'firebase';\r\nimport Peer from 'simple-peer';\r\nimport { BrowserRouter } from 'react-router-dom';\r\n\r\nconst firebase = { firestore, auth, initializeApp };\r\nconsole.log(process.env.REACT_APP_PEER_FIREBASE);\r\nconst UserDB = async () => {\r\n  const firebaseConfig = JSON.parse(process.env.REACT_APP_PEER_FIREBASE);\r\n\r\n  firebase.initializeApp(firebaseConfig);\r\n  const db = firebase.firestore();\r\n  console.log('initializing firebase');\r\n\r\n  const userAuth = await firebase.auth().signInAnonymously();\r\n  console.log('user auth uid:', userAuth.user.uid);\r\n\r\n  let existingUserRef = await db\r\n    .collection('user')\r\n    .doc(userAuth.user.uid)\r\n    .get();\r\n  console.log('==== user existing info ====');\r\n  console.log('user has existing info status:', existingUserRef.exists);\r\n  console.log('user existing info id:', existingUserRef.id);\r\n  console.log('user existing info:', existingUserRef.data());\r\n\r\n  if (!(existingUserRef && existingUserRef.exists)) {\r\n    await db.collection('user').doc(userAuth.user.uid).set({\r\n      authenInfo: null,\r\n      friendList: [],\r\n      roomOwner: [],\r\n      roomMemeber: [],\r\n    });\r\n  }\r\n  const userRef = await db.collection('user').doc(userAuth.user.uid);\r\n  console.log('userRef:', userRef);\r\n  console.log('userRef id:', userRef.id);\r\n\r\n  const firebaseTimeToTimestamp = (firebaseTimestamp) => {\r\n    const { seconds, nanoseconds } = firebaseTimestamp;\r\n\r\n    const timestamp = new firebase.firestore.Timestamp(\r\n      seconds,\r\n      nanoseconds\r\n    ).toMillis();\r\n\r\n    return timestamp;\r\n  };\r\n  const processCallerData = async (docID) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      let doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        const { callerPayload, from, lastUpdated } = doc.data();\r\n        let { callerMsgInd, callerMsgCnt } = doc.data();\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming caller msg:', {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (callerMsgInd >= callerMsgCnt || expired) {\r\n          console.log('no caller msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, callerPayload);\r\n        const copyMsgInd = callerMsgInd;\r\n\r\n        //process incoming data\r\n        while (callerMsgInd < callerMsgCnt)\r\n          delete callerPayload[callerMsgInd++];\r\n        console.log('updating remote copy:', { callerPayload, callerMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          callerPayload: copyPayload,\r\n          callerMsgInd: copyMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n  const processCalleeData = async (docID) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      const doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        let { calleePayload, to, lastUpdated } = doc.data();\r\n        let { calleeMsgInd, calleeMsgCnt } = doc.data();\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming callee msg:', {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (calleeMsgInd >= calleeMsgCnt || expired) {\r\n          console.log('no callee msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, calleePayload);\r\n        const copyMsgInd = calleeMsgInd;\r\n\r\n        //process incoming data\r\n        while (calleeMsgInd < calleeMsgCnt)\r\n          delete calleePayload[calleeMsgInd++];\r\n        console.log('updating remote copy:', { calleePayload, calleeMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          calleePayload: copyPayload,\r\n          calleeMsgInd: copyMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n\r\n  return {\r\n    userID: function () {\r\n      return userRef.id;\r\n    },\r\n    userInfo: function () {\r\n      if (userRef === null) {\r\n      }\r\n    },\r\n    on: function (roomID, message, callback) {\r\n      // db.collection(`msg-queue`)\r\n      //   .where('roomID', '==', roomID)\r\n      //   .where('message', '==', message)\r\n      //   .where('msgRead', '==', false)\r\n      //   .where('to', '==', userRef.id)\r\n      //   .onSnapshot(async (snapshot) => {\r\n      //     snapshot.forEach(async (doc) => {\r\n      //       console.log('incoming msg doc id:', doc.id);\r\n      //       console.log('incoming msg doc data:', doc.data());\r\n      //       const response = await callback(doc.data());\r\n      //       db.doc(`msg-queue/${doc.id}`).update({ response, msgRead: true });\r\n      //     });\r\n      //   });\r\n    },\r\n    onCallerMsg: function (roomID, message, callback) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('to', '==', userRef.id)\r\n        .where('callerMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCallerData(doc.id);\r\n\r\n              if (data) {\r\n                const {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                  from,\r\n                } = data;\r\n                console.log('processing payload:', {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                });\r\n                await callback(callerPayload, callerMsgInd, callerMsgCnt, from);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    onCalleeMsg: function (roomID, message, callback) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('from', '==', userRef.id)\r\n        .where('calleeMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCalleeData(doc.id);\r\n\r\n              if (data) {\r\n                const { calleePayload, calleeMsgInd, calleeMsgCnt, to } = data;\r\n\r\n                await callback(calleePayload, calleeMsgInd, calleeMsgCnt, to);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    sendCallerAResponse: async function (data, from) {\r\n      const connectionID = [from, userRef.id].sort().join('_');\r\n      console.log('responding to caller:', from);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          let { calleePayload, calleeMsgCnt, calleeMsgInd } = doc.data();\r\n\r\n          calleePayload[calleeMsgCnt] = data;\r\n          calleeMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            calleeMsgCnt,\r\n            calleePayload,\r\n            calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n          });\r\n        }\r\n      });\r\n    },\r\n    sendCalleeAResponse: async function (data, to) {\r\n      const connectionID = [to, userRef.id].sort().join('_');\r\n      console.log('responding to callee:', to);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          let { callerPayload, callerMsgCnt, callerMsgInd } = doc.data();\r\n\r\n          callerPayload[callerMsgCnt] = data;\r\n          callerMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            callerMsgCnt,\r\n            callerPayload,\r\n            callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n          });\r\n        }\r\n      });\r\n    },\r\n    initiateConnection: async function (roomID, message, to) {\r\n      try {\r\n        const connectionID = [to, userRef.id].sort().join('_');\r\n        console.log('initiating connnection from:', userRef.id);\r\n        console.log('connection id:', connectionID);\r\n        console.log({ roomID, message, to, from: userRef.id });\r\n\r\n        // check if other caller is in control\r\n        const connectionRef = await db.doc(`connection/${connectionID}`);\r\n\r\n        await db.runTransaction(async (transaction) => {\r\n          const priorConnectionDoc = await transaction.get(connectionRef);\r\n\r\n          const priorConData =\r\n            priorConnectionDoc.exists === true\r\n              ? priorConnectionDoc.data()\r\n              : null;\r\n          let priorConExpired = false;\r\n\r\n          if (priorConData) {\r\n            const controlLastUpdated = this.firebaseTimeToTimestamp(\r\n              priorConData.lastUpdated\r\n            );\r\n            const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n            priorConExpired = currentTime - controlLastUpdated >= 30000; //expired after 30 seconds\r\n\r\n            console.log(\r\n              'prior control expire status:',\r\n              priorConExpired,\r\n              ', milisecond elapsed:',\r\n              currentTime - controlLastUpdated\r\n            );\r\n          }\r\n\r\n          if (priorConData === null || priorConExpired) {\r\n            // initiate connection\r\n            console.log('creating new connection');\r\n            await transaction.set(connectionRef, {\r\n              from: userRef.id,\r\n              to,\r\n              roomID,\r\n              message,\r\n              // =============\r\n              callerMsgCnt: 1,\r\n              callerMsgInd: 0,\r\n              callerMsgDiff: 1,\r\n              callerPayload: { 0: CALLER_MSG_INITIATE },\r\n              // ==============\r\n              calleeMsgCnt: 0,\r\n              calleeMsgInd: 0,\r\n              calleeMsgDiff: 0,\r\n              calleePayload: {},\r\n              // ==============\r\n              lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            });\r\n          }\r\n        });\r\n      } catch (e) {\r\n        console.error('msg send error:', e);\r\n      }\r\n    },\r\n    emit: async function (roomID, message, data, to) {},\r\n    respond: async function (roomID, message, data, to) {},\r\n    sendAndWaitForResponse: async function (\r\n      roomID,\r\n      message,\r\n      payload,\r\n      to,\r\n      timeout = 5000\r\n    ) {\r\n      console.log('creating message for:', userRef.id);\r\n      console.log({ roomID, message, payload, from: userRef.id, to, timeout });\r\n      try {\r\n        await db.doc(`msg-queue/${userRef.id}`).set({\r\n          from: userRef.id,\r\n          response: null,\r\n          msgRead: false,\r\n          to,\r\n          message,\r\n          roomID,\r\n          payload,\r\n        });\r\n      } catch (e) {\r\n        console.error('msg send error:', e);\r\n      }\r\n      const TIMEOUT_FLAG = 'timeout';\r\n      let unsubListener = null;\r\n      let isTimedout = true;\r\n\r\n      const responsePromise = new Promise((resolve, reject) => {\r\n        unsubListener = db.doc(`msg-queue/${userRef.id}`).onSnapshot((doc) => {\r\n          const { msgRead, response } = doc.data();\r\n          if (msgRead === true) {\r\n            unsubListener();\r\n            console.log('recieved response:', doc.data());\r\n            isTimedout = false;\r\n            resolve(response);\r\n          }\r\n        });\r\n      });\r\n      const timeoutPromise = new Promise((resolve, reject) =>\r\n        setTimeout(() => {\r\n          if (isTimedout) {\r\n            console.error('Promise Timeout');\r\n            console.log('unsub listener');\r\n            unsubListener();\r\n            reject(TIMEOUT_FLAG);\r\n          } else {\r\n            resolve();\r\n          }\r\n        }, timeout)\r\n      );\r\n      const result = await Promise.race([responsePromise, timeoutPromise]);\r\n\r\n      return result;\r\n    },\r\n    joinRoom: async function (roomID) {\r\n      try {\r\n        console.log('joining room:', roomID);\r\n        if (roomID) {\r\n          const docRef = await db.doc(`room/${roomID}`);\r\n          const doc = await docRef.get();\r\n\r\n          if (doc && doc.exists) {\r\n            console.log('userRef in room:', userRef.id);\r\n            const user = {\r\n              ['user.' +\r\n              userRef.id]: firebase.firestore.Timestamp.now().toDate(),\r\n            };\r\n            console.log('room data:', doc.data());\r\n            console.log('msg queue data:', user);\r\n            await docRef.update(user);\r\n            const updatedDoc = await docRef.get();\r\n            // await db.doc(`room/${roomID}`).onSnapshot(async (doc) => {\r\n            //   const data = doc.data();\r\n            //   const queue = data.userMsgQueue[userRef.id];\r\n\r\n            //   if (queue.length > 0) {\r\n            //     console.log('consuming data:', queue);\r\n            //     const blankQueue = { ['userMsgQueue.' + userRef.id]: [] };\r\n            //     await docRef.update(blankQueue);\r\n            //   }\r\n            // });\r\n\r\n            return updatedDoc.data();\r\n          } else {\r\n            console.log(\"room doesn't exist:\", roomID);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        console.error('join room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    createRoom: async function () {\r\n      try {\r\n        const docRef = await db.collection('room').add({\r\n          user: {},\r\n          created: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n        const res = await userRef.update({\r\n          roomOwner: firebase.firestore.FieldValue.arrayUnion(docRef.id),\r\n        });\r\n        console.log('create room id:', docRef.id);\r\n        console.log('create room info:', res);\r\n        return docRef.id;\r\n      } catch (e) {\r\n        console.error('create room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    firebaseTimeToTimestamp: firebaseTimeToTimestamp,\r\n  };\r\n};\r\n\r\nconst CALLER_MSG_INITIATE = 'initiate';\r\n\r\nconst CALLEE_MSG_ACCEPT = 'callee-accept';\r\n\r\nconst PEER_STATE_0 = 'not-connected';\r\nconst PEER_STATE_1 = 'initiated';\r\nconst PEER_STATE_2 = 'connecting';\r\nconst PEER_STATE_3 = 'connected';\r\nconst PEER_STATE_4 = 'failed';\r\n\r\nconst PeerInfo = function (id) {\r\n  this.id = id;\r\n  this.state = PEER_STATE_0;\r\n  this.peer = null;\r\n};\r\n\r\n// reference:\r\n// https://ui.dev/react-router-v4-programmatically-navigate/\r\n// const CreateRoom = withRouter(({ ...props }) => {\r\n//   const create = async () => {\r\n//     // const id = uuid();\r\n//     // const roomId = await props.createRoom();\r\n//     // props.history.push(`/room/${roomId}`);\r\n\r\n//     console.log('this is some props -->', props);\r\n//   };\r\n//   return <button onClick={create}>Create room</button>;\r\n// });\r\nconst Video = (props) => {\r\n  const ref = useRef();\r\n\r\n  useEffect(() => {\r\n    props.peer.on('stream', (stream) => {\r\n      console.log('peer stream:', stream);\r\n      ref.current.srcObject = stream;\r\n    });\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <video playsInline autoPlay ref={ref}></video>\r\n    </div>\r\n  );\r\n};\r\nconst Room = withRouter(({ ...props }) => {\r\n  const userVideoRef = useRef();\r\n  const roomID = props.match.params.id;\r\n  const videoConstraints = {\r\n    height: window.innerHeight / 2,\r\n    width: window.innerWidth / 2,\r\n  };\r\n  console.log('roomID-->', roomID, 'props -->', props);\r\n  const userDB = props.userDB;\r\n\r\n  // ==============\r\n  const userInRoomRef = useRef();\r\n  const [userInRoomState, setUserInRoomState] = useState({});\r\n\r\n  useEffect(() => {\r\n    if (userDB === undefined) {\r\n      //return if not initialized\r\n      return;\r\n    }\r\n    if (userInRoomRef.current === undefined) {\r\n      userInRoomRef.current = {};\r\n    }\r\n    navigator.mediaDevices\r\n      .getUserMedia({ video: videoConstraints, audio: false })\r\n      .then(gotMedia);\r\n  }, []);\r\n  const gotMedia = async (stream) => {\r\n    userVideoRef.current.srcObject = stream;\r\n\r\n    const roomInfo = await userDB.joinRoom(roomID);\r\n    if (roomInfo === null) {\r\n      alert('This room does not exist.');\r\n      props.history.push(`/`);\r\n    }\r\n\r\n    //0. initialize list of user in room\r\n    for (const userID in roomInfo.user) {\r\n      if (userID !== userDB.userID()) {\r\n        userInRoomRef.current[userID] = new PeerInfo(userID);\r\n      }\r\n    }\r\n    setUserInRoomState({});\r\n\r\n    //1. register listener to incoming request to connect\r\n    userDB.onCallerMsg(\r\n      roomID,\r\n      'request-connect',\r\n      async (callerPayload, callerMsgInd, callerMsgCnt, from) => {\r\n        while (callerMsgInd < callerMsgCnt) {\r\n          const msg = callerPayload[callerMsgInd++];\r\n\r\n          if (userInRoomRef.current[from] === undefined) {\r\n            userInRoomRef.current[from] = new PeerInfo(from);\r\n          }\r\n          const currentPeerInfo = userInRoomRef.current[from];\r\n\r\n          if (\r\n            currentPeerInfo.state === PEER_STATE_0 &&\r\n            msg === CALLER_MSG_INITIATE\r\n          ) {\r\n            currentPeerInfo.state = PEER_STATE_1;\r\n\r\n            // initiate call\r\n            console.log('initiation recieved from:', from);\r\n            await userDB.sendCallerAResponse(CALLEE_MSG_ACCEPT, from);\r\n          } else if (currentPeerInfo.state === PEER_STATE_1) {\r\n            currentPeerInfo.state = PEER_STATE_2;\r\n\r\n            // process offer\r\n            console.log('recieved offer recieved from:', from);\r\n            console.log('offer:', msg);\r\n            currentPeerInfo.peer = addPeer(msg, from, stream, (signal) => {\r\n              userDB.sendCallerAResponse(signal, from);\r\n            });\r\n            //listen to peer events\r\n            currentPeerInfo.peer.on('connect', () => {\r\n              console.log(\r\n                'connection connected:',\r\n                userInRoomRef.current[from].id\r\n              );\r\n              userInRoomRef.current[from].state = PEER_STATE_3;\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('close', () => {\r\n              userInRoomRef.current[from].state = PEER_STATE_0;\r\n              console.log('connection closed:', userInRoomRef.current[from].id);\r\n\r\n              if (userInRoomRef.current[from].peer) {\r\n                userInRoomRef.current[from].peer.destroy();\r\n                userInRoomRef.current[from].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('error', (err) => {\r\n              console.log(\r\n                'connection error:',\r\n                userInRoomRef.current[from].id,\r\n                err\r\n              );\r\n\r\n              userInRoomRef.current[from].state = PEER_STATE_4;\r\n              if (userInRoomRef.current[from].peer) {\r\n                userInRoomRef.current[from].peer.destroy();\r\n                userInRoomRef.current[from].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n\r\n            // process offer\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else if (\r\n            currentPeerInfo.state === PEER_STATE_2 ||\r\n            currentPeerInfo.state === PEER_STATE_3\r\n          ) {\r\n            // process ICE\r\n            console.log('recieved ICE recieved from:', from);\r\n            console.log('ICE:', msg);\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else {\r\n            // bad state, clean up\r\n            currentPeerInfo.state = PEER_STATE_4;\r\n            if (currentPeerInfo.peer) {\r\n              currentPeerInfo.peer.destroy();\r\n              currentPeerInfo.peer = undefined;\r\n            }\r\n          }\r\n        }\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n    //2. register listener to incoming responses from callee\r\n    userDB.onCalleeMsg(\r\n      roomID,\r\n      'response-signal',\r\n      async (calleePayload, calleeMsgInd, calleeMsgCnt, to) => {\r\n        while (calleeMsgInd < calleeMsgCnt) {\r\n          const msg = calleePayload[calleeMsgInd++];\r\n\r\n          if (userInRoomRef.current[to] === undefined) {\r\n            userInRoomRef.current[to] = new PeerInfo(to);\r\n          }\r\n          const currentPeerInfo = userInRoomRef.current[to];\r\n\r\n          if (\r\n            //callee accepted\r\n            currentPeerInfo.state === PEER_STATE_0 &&\r\n            msg === CALLEE_MSG_ACCEPT\r\n          ) {\r\n            currentPeerInfo.state = PEER_STATE_1;\r\n\r\n            // callee accepted, create and send offer to be sent\r\n            console.log('callee accepted call:', to);\r\n\r\n            currentPeerInfo.peer = createPeer(to, stream, (signal) => {\r\n              userDB.sendCalleeAResponse(signal, to);\r\n            });\r\n\r\n            //listen to peer events\r\n            currentPeerInfo.peer.on('connect', () => {\r\n              userInRoomRef.current[to].state = PEER_STATE_3;\r\n              console.log('connection connect:', userInRoomRef.current[to].id);\r\n\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('close', () => {\r\n              console.log('connection cosed:', userInRoomRef.current[to].id);\r\n\r\n              userInRoomRef.current[to].state = PEER_STATE_0;\r\n              if (userInRoomRef.current[to].peer) {\r\n                userInRoomState[to].peer.destroy();\r\n                userInRoomState[to].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('error', (err) => {\r\n              console.log(\r\n                'connection error:',\r\n                userInRoomRef.current[to].id,\r\n                err\r\n              );\r\n\r\n              userInRoomRef.current[to].state = PEER_STATE_4;\r\n              if (userInRoomRef.currentom[to].peer) {\r\n                userInRoomRef.current[to].peer.destroy();\r\n                userInRoomRef.current[to].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n          } else if (\r\n            currentPeerInfo.state === PEER_STATE_1 ||\r\n            currentPeerInfo.state === PEER_STATE_2 ||\r\n            currentPeerInfo.state === PEER_STATE_3\r\n          ) {\r\n            //process callee accepted and ICE candidate\r\n            if (currentPeerInfo.state === PEER_STATE_1) {\r\n              currentPeerInfo.state = PEER_STATE_2;\r\n            }\r\n\r\n            // process offer\r\n            console.log('recieved answer/ICE recieved from callee:', to);\r\n            console.log('callee data:', msg);\r\n\r\n            // process offer\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else {\r\n            // bad state, clean up\r\n            currentPeerInfo.state = PEER_STATE_4;\r\n            if (currentPeerInfo.peer) {\r\n              currentPeerInfo.peer.destroy();\r\n              currentPeerInfo.peer = undefined;\r\n            }\r\n          }\r\n        }\r\n\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n\r\n    //3. call existing peers in room\r\n    callPeerInRoom(stream, roomInfo);\r\n  };\r\n  const callPeerInRoom = (stream, roomInfo) => {\r\n    //3. call each user in the roo\r\n    console.log({ roomInfo });\r\n    const userInRoom = roomInfo.user;\r\n    const currentUserID = userDB.userID();\r\n    const joinedTimestamp = userDB.firebaseTimeToTimestamp(\r\n      userInRoom[currentUserID]\r\n    );\r\n    console.log('current user joined room timestamp:', joinedTimestamp);\r\n\r\n    for (const peerID in userInRoom) {\r\n      const timestamp = userDB.firebaseTimeToTimestamp(userInRoom[peerID]);\r\n\r\n      // call users that were on before current user\r\n      if (peerID !== currentUserID && timestamp < joinedTimestamp) {\r\n        callPeer(peerID, stream, roomID);\r\n      }\r\n    }\r\n  };\r\n  const callPeer = (peerID, stream, roomID) => {\r\n    userDB.initiateConnection(roomID, 'initiate-connection', peerID);\r\n  };\r\n  const createPeer = (userToSignal, stream, onSignal) => {\r\n    const peer = new Peer({\r\n      initiator: true,\r\n      trickle: false,\r\n      stream: stream,\r\n    });\r\n    console.log('peer created -->', peer);\r\n    peer.on('signal', (signal) => {\r\n      console.log('signal created for:', userToSignal, signal);\r\n      onSignal(signal);\r\n    });\r\n\r\n    return peer;\r\n  };\r\n  const addPeer = (incomingSignal, callerID, stream, onSignal) => {\r\n    const peer = new Peer({\r\n      initiator: false,\r\n      trickle: false,\r\n      stream,\r\n    });\r\n    peer.on('signal', (signal) => {\r\n      console.log('returning signal created for', callerID, signal);\r\n      onSignal(signal);\r\n    });\r\n    return peer;\r\n  };\r\n\r\n  const peerList = [];\r\n  for (const peerid in userInRoomRef.current) {\r\n    if (userInRoomRef.current[peerid].peer) {\r\n      peerList.push(userInRoomRef.current[peerid].peer);\r\n    }\r\n  }\r\n  const stateToColor = {\r\n    failed: 'red',\r\n    initiated: 'orange',\r\n    'not-connected': 'grey',\r\n    connecting: 'yellow',\r\n    connected: 'green',\r\n  };\r\n\r\n  const stat = !userInRoomRef.current\r\n    ? null\r\n    : Object.keys(userInRoomRef.current).map((key) => {\r\n        return (\r\n          <li key={key}>\r\n            User ID: {key} Status:{' '}\r\n            <span\r\n              style={{\r\n                backgroundColor: stateToColor[userInRoomRef.current[key].state],\r\n              }}\r\n            >\r\n              {userInRoomRef.current[key].state}\r\n            </span>\r\n          </li>\r\n        );\r\n      });\r\n  console.log('peer list:', peerList);\r\n  console.log(userInRoomRef.current);\r\n  return (\r\n    <div>\r\n      <h3>My User ID: {userDB ? userDB.userID() : undefined}</h3>\r\n      <video muted ref={userVideoRef} autoPlay playsInline></video>\r\n      <h3>User In Room:</h3>\r\n      <ul>{stat}</ul>\r\n      <hr></hr>\r\n      {peerList.map((peer, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {index}\r\n            <Video peer={peer}></Video>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n});\r\n\r\nconst App = (props) => {\r\n  const [userDB, setUserDB] = useState();\r\n  const [roomPath, setRoomPath] = useState(null);\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      const userDB = await UserDB();\r\n      setUserDB(userDB);\r\n    })();\r\n  }, []);\r\n\r\n  const createRoom = async () => {\r\n    const roomId = await userDB.createRoom();\r\n    setRoomPath(`/room/${roomId}`);\r\n  };\r\n  return (\r\n    <BrowserRouter basename={process.env.PUBLIC_URL}>\r\n      <React.StrictMode>\r\n        <button onClick={createRoom}>Create Room</button>\r\n        <Switch>\r\n          {roomPath ? <Redirect to={roomPath} /> : undefined}\r\n          <Route\r\n            path='/room/:id'\r\n            component={() => <Room {...props} userDB={userDB} />}\r\n          ></Route>\r\n          <Route component={<div>Not Found</div>} />\r\n        </Switch>\r\n      </React.StrictMode>\r\n    </BrowserRouter>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}