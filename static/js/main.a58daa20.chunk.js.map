{"version":3,"sources":["App.js","index.js"],"names":["firebase","firestore","auth","initializeApp","UserDB","a","str","process","slice","firebaseConfig","JSON","parse","db","console","log","signInAnonymously","userAuth","user","uid","collection","doc","get","existingUserRef","exists","id","data","set","authenInfo","friendList","roomOwner","roomMemeber","userRef","firebaseTimeToTimestamp","firebaseTimestamp","seconds","nanoseconds","Timestamp","toMillis","processCallerData","docID","docRef","runTransaction","transaction","callerPayload","from","lastUpdated","callerMsgInd","callerMsgCnt","currentTime","now","lastUpdateMili","expired","copyPayload","Object","assign","copyMsgInd","update","callerMsgDiff","toDate","processCalleeData","calleePayload","to","calleeMsgInd","calleeMsgCnt","calleeMsgDiff","userID","userInfo","on","roomID","message","callback","onCallerMsg","where","onSnapshot","snapshot","forEach","onCalleeMsg","sendCallerAResponse","connectionID","sort","join","increment","FieldValue","TextEncoder","encode","stringify","length","payloadByteUsed","sendCalleeAResponse","initiateConnection","connectionRef","priorConnectionDoc","priorConData","priorConExpired","controlLastUpdated","0","CALLER_MSG_INITIATE","error","emit","respond","sendAndWaitForResponse","payload","timeout","response","msgRead","TIMEOUT_FLAG","unsubListener","isTimedout","responsePromise","Promise","resolve","reject","timeoutPromise","setTimeout","race","result","joinRoom","updatedDoc","createRoom","add","created","arrayUnion","res","PeerInfo","this","state","peer","Video","props","ref","useRef","useEffect","stream","current","srcObject","playsInline","autoPlay","Room","withRouter","userVideoRef","match","params","videoConstraints","height","window","innerHeight","width","innerWidth","userDB","userInRoomRef","useState","userInRoomState","setUserInRoomState","undefined","navigator","mediaDevices","getUserMedia","video","audio","then","gotMedia","roomInfo","alert","history","push","msg","currentPeerInfo","addPeer","signal","destroy","err","createPeer","currentom","callPeerInRoom","userInRoom","currentUserID","joinedTimestamp","peerID","timestamp","callPeer","userToSignal","onSignal","Peer","initiator","trickle","incomingSignal","callerID","peerList","peerid","stateToColor","failed","initiated","connecting","connected","stat","keys","map","key","style","backgroundColor","muted","index","App","setUserDB","roomPath","setRoomPath","roomId","basename","StrictMode","onClick","path","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a58daa20.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { withRouter, Route, Switch, Redirect } from 'react-router-dom';\r\nimport './App.css';\r\nimport { firestore, auth, initializeApp } from 'firebase';\r\nimport Peer from 'simple-peer';\r\nimport { BrowserRouter, HashRouter } from 'react-router-dom';\r\n\r\nconst firebase = { firestore, auth, initializeApp };\r\nconst UserDB = async () => {\r\n  const str = process.env.REACT_APP_PEER_FIREBASE.slice(1, -1);\r\n  const firebaseConfig = JSON.parse(str);\r\n\r\n  firebase.initializeApp(firebaseConfig);\r\n  const db = firebase.firestore();\r\n  console.log('initializing firebase');\r\n\r\n  const userAuth = await firebase.auth().signInAnonymously();\r\n  console.log('user auth uid:', userAuth.user.uid);\r\n\r\n  let existingUserRef = await db\r\n    .collection('user')\r\n    .doc(userAuth.user.uid)\r\n    .get();\r\n  console.log('==== user existing info ====');\r\n  console.log('user has existing info status:', existingUserRef.exists);\r\n  console.log('user existing info id:', existingUserRef.id);\r\n  console.log('user existing info:', existingUserRef.data());\r\n\r\n  if (!(existingUserRef && existingUserRef.exists)) {\r\n    await db.collection('user').doc(userAuth.user.uid).set({\r\n      authenInfo: null,\r\n      friendList: [],\r\n      roomOwner: [],\r\n      roomMemeber: [],\r\n    });\r\n  }\r\n  const userRef = await db.collection('user').doc(userAuth.user.uid);\r\n  console.log('userRef:', userRef);\r\n  console.log('userRef id:', userRef.id);\r\n\r\n  const firebaseTimeToTimestamp = (firebaseTimestamp) => {\r\n    const { seconds, nanoseconds } = firebaseTimestamp;\r\n\r\n    const timestamp = new firebase.firestore.Timestamp(\r\n      seconds,\r\n      nanoseconds\r\n    ).toMillis();\r\n\r\n    return timestamp;\r\n  };\r\n  const processCallerData = async (docID) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      let doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        const { callerPayload, from, lastUpdated } = doc.data();\r\n        let { callerMsgInd, callerMsgCnt } = doc.data();\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming caller msg:', {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (callerMsgInd >= callerMsgCnt || expired) {\r\n          console.log('no caller msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, callerPayload);\r\n        const copyMsgInd = callerMsgInd;\r\n\r\n        //process incoming data\r\n        while (callerMsgInd < callerMsgCnt)\r\n          delete callerPayload[callerMsgInd++];\r\n        console.log('updating remote copy:', { callerPayload, callerMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          callerPayload,\r\n          callerMsgInd,\r\n          callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          callerPayload: copyPayload,\r\n          callerMsgInd: copyMsgInd,\r\n          callerMsgCnt,\r\n          from,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n  const processCalleeData = async (docID) => {\r\n    const docRef = await db.doc(`connection/${docID}`);\r\n    return await db.runTransaction(async (transaction) => {\r\n      const doc = await transaction.get(docRef);\r\n      if (doc.exists) {\r\n        let { calleePayload, to, lastUpdated } = doc.data();\r\n        let { calleeMsgInd, calleeMsgCnt } = doc.data();\r\n\r\n        const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n        const lastUpdateMili = firebaseTimeToTimestamp(lastUpdated);\r\n        const expired = currentTime - lastUpdateMili >= 30000;\r\n\r\n        console.log('incoming callee msg:', {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n          lastUpdateMili,\r\n          currentTime,\r\n          expired,\r\n        });\r\n\r\n        if (calleeMsgInd >= calleeMsgCnt || expired) {\r\n          console.log('no callee msg to process');\r\n          return null;\r\n        }\r\n\r\n        const copyPayload = Object.assign({}, calleePayload);\r\n        const copyMsgInd = calleeMsgInd;\r\n\r\n        //process incoming data\r\n        while (calleeMsgInd < calleeMsgCnt)\r\n          delete calleePayload[calleeMsgInd++];\r\n        console.log('updating remote copy:', { calleePayload, calleeMsgInd });\r\n\r\n        await transaction.update(docRef, {\r\n          calleePayload,\r\n          calleeMsgInd,\r\n          calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n          lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n\r\n        return {\r\n          calleePayload: copyPayload,\r\n          calleeMsgInd: copyMsgInd,\r\n          calleeMsgCnt,\r\n          to,\r\n        };\r\n      }\r\n      return null;\r\n    });\r\n  };\r\n\r\n  return {\r\n    userID: function () {\r\n      return userRef.id;\r\n    },\r\n    userInfo: function () {\r\n      if (userRef === null) {\r\n      }\r\n    },\r\n    on: function (roomID, message, callback) {\r\n      // db.collection(`msg-queue`)\r\n      //   .where('roomID', '==', roomID)\r\n      //   .where('message', '==', message)\r\n      //   .where('msgRead', '==', false)\r\n      //   .where('to', '==', userRef.id)\r\n      //   .onSnapshot(async (snapshot) => {\r\n      //     snapshot.forEach(async (doc) => {\r\n      //       console.log('incoming msg doc id:', doc.id);\r\n      //       console.log('incoming msg doc data:', doc.data());\r\n      //       const response = await callback(doc.data());\r\n      //       db.doc(`msg-queue/${doc.id}`).update({ response, msgRead: true });\r\n      //     });\r\n      //   });\r\n    },\r\n    onCallerMsg: function (roomID, message, callback) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('to', '==', userRef.id)\r\n        .where('callerMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCallerData(doc.id);\r\n\r\n              if (data) {\r\n                const {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                  from,\r\n                } = data;\r\n                console.log('processing payload:', {\r\n                  callerPayload,\r\n                  callerMsgInd,\r\n                  callerMsgCnt,\r\n                });\r\n                await callback(callerPayload, callerMsgInd, callerMsgCnt, from);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    onCalleeMsg: function (roomID, message, callback) {\r\n      db.collection('connection')\r\n        .where('roomID', '==', roomID)\r\n        .where('from', '==', userRef.id)\r\n        .where('calleeMsgDiff', '>', 0)\r\n        .onSnapshot((snapshot) => {\r\n          snapshot.forEach(async (doc) => {\r\n            if (doc.exists) {\r\n              const data = await processCalleeData(doc.id);\r\n\r\n              if (data) {\r\n                const { calleePayload, calleeMsgInd, calleeMsgCnt, to } = data;\r\n\r\n                await callback(calleePayload, calleeMsgInd, calleeMsgCnt, to);\r\n              }\r\n            }\r\n          });\r\n        });\r\n    },\r\n    sendCallerAResponse: async function (data, from) {\r\n      const connectionID = [from, userRef.id].sort().join('_');\r\n      console.log('responding to caller:', from);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          let { calleePayload, calleeMsgCnt, calleeMsgInd } = doc.data();\r\n\r\n          // get byte count of payload/data\r\n          const increment = firebase.firestore.FieldValue.increment(\r\n            new TextEncoder().encode(JSON.stringify(data)).length\r\n          );\r\n\r\n          calleePayload[calleeMsgCnt] = data;\r\n          calleeMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            calleeMsgCnt,\r\n            calleePayload,\r\n            calleeMsgDiff: calleeMsgCnt - calleeMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            payloadByteUsed: increment,\r\n          });\r\n        }\r\n      });\r\n    },\r\n    sendCalleeAResponse: async function (data, to) {\r\n      const connectionID = [to, userRef.id].sort().join('_');\r\n      console.log('responding to callee:', to);\r\n      console.log('connection id:', connectionID);\r\n      console.log({ data });\r\n\r\n      const docRef = await db.doc(`connection/${connectionID}`);\r\n\r\n      await db.runTransaction(async (transaction) => {\r\n        const doc = await transaction.get(docRef);\r\n\r\n        if (doc.exists) {\r\n          let { callerPayload, callerMsgCnt, callerMsgInd } = doc.data();\r\n\r\n          // get byte count of payload/data\r\n          const increment = firebase.firestore.FieldValue.increment(\r\n            new TextEncoder().encode(JSON.stringify(data)).length\r\n          );\r\n\r\n          callerPayload[callerMsgCnt] = data;\r\n          callerMsgCnt++;\r\n\r\n          await transaction.update(docRef, {\r\n            callerMsgCnt,\r\n            callerPayload,\r\n            callerMsgDiff: callerMsgCnt - callerMsgInd,\r\n            lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            payloadByteUsed: increment,\r\n          });\r\n        }\r\n      });\r\n    },\r\n    initiateConnection: async function (roomID, message, to) {\r\n      try {\r\n        const connectionID = [to, userRef.id].sort().join('_');\r\n        console.log('initiating connnection from:', userRef.id);\r\n        console.log('connection id:', connectionID);\r\n        console.log({ roomID, message, to, from: userRef.id });\r\n\r\n        // check if other caller is in control\r\n        const connectionRef = await db.doc(`connection/${connectionID}`);\r\n\r\n        await db.runTransaction(async (transaction) => {\r\n          const priorConnectionDoc = await transaction.get(connectionRef);\r\n\r\n          const priorConData =\r\n            priorConnectionDoc.exists === true\r\n              ? priorConnectionDoc.data()\r\n              : null;\r\n          let priorConExpired = false;\r\n\r\n          if (priorConData) {\r\n            const controlLastUpdated = this.firebaseTimeToTimestamp(\r\n              priorConData.lastUpdated\r\n            );\r\n            const currentTime = firebase.firestore.Timestamp.now().toMillis();\r\n            priorConExpired = currentTime - controlLastUpdated >= 30000; //expired after 30 seconds\r\n\r\n            console.log(\r\n              'prior control expire status:',\r\n              priorConExpired,\r\n              ', milisecond elapsed:',\r\n              currentTime - controlLastUpdated\r\n            );\r\n          }\r\n\r\n          if (priorConData === null || priorConExpired) {\r\n            // initiate connection\r\n            console.log('creating new connection');\r\n            await transaction.set(connectionRef, {\r\n              from: userRef.id,\r\n              to,\r\n              roomID,\r\n              message,\r\n              // =============\r\n              callerMsgCnt: 1,\r\n              callerMsgInd: 0,\r\n              callerMsgDiff: 1,\r\n              callerPayload: { 0: CALLER_MSG_INITIATE },\r\n              // ==============\r\n              calleeMsgCnt: 0,\r\n              calleeMsgInd: 0,\r\n              calleeMsgDiff: 0,\r\n              calleePayload: {},\r\n              // ==============\r\n              payloadByteUsed: 0,\r\n              lastUpdated: firebase.firestore.Timestamp.now().toDate(),\r\n            });\r\n          }\r\n        });\r\n      } catch (e) {\r\n        console.error('msg send error:', e);\r\n      }\r\n    },\r\n    emit: async function (roomID, message, data, to) {},\r\n    respond: async function (roomID, message, data, to) {},\r\n    sendAndWaitForResponse: async function (\r\n      roomID,\r\n      message,\r\n      payload,\r\n      to,\r\n      timeout = 5000\r\n    ) {\r\n      console.log('creating message for:', userRef.id);\r\n      console.log({ roomID, message, payload, from: userRef.id, to, timeout });\r\n      try {\r\n        await db.doc(`msg-queue/${userRef.id}`).set({\r\n          from: userRef.id,\r\n          response: null,\r\n          msgRead: false,\r\n          to,\r\n          message,\r\n          roomID,\r\n          payload,\r\n        });\r\n      } catch (e) {\r\n        console.error('msg send error:', e);\r\n      }\r\n      const TIMEOUT_FLAG = 'timeout';\r\n      let unsubListener = null;\r\n      let isTimedout = true;\r\n\r\n      const responsePromise = new Promise((resolve, reject) => {\r\n        unsubListener = db.doc(`msg-queue/${userRef.id}`).onSnapshot((doc) => {\r\n          const { msgRead, response } = doc.data();\r\n          if (msgRead === true) {\r\n            unsubListener();\r\n            console.log('recieved response:', doc.data());\r\n            isTimedout = false;\r\n            resolve(response);\r\n          }\r\n        });\r\n      });\r\n      const timeoutPromise = new Promise((resolve, reject) =>\r\n        setTimeout(() => {\r\n          if (isTimedout) {\r\n            console.error('Promise Timeout');\r\n            console.log('unsub listener');\r\n            unsubListener();\r\n            reject(TIMEOUT_FLAG);\r\n          } else {\r\n            resolve();\r\n          }\r\n        }, timeout)\r\n      );\r\n      const result = await Promise.race([responsePromise, timeoutPromise]);\r\n\r\n      return result;\r\n    },\r\n    joinRoom: async function (roomID) {\r\n      try {\r\n        console.log('joining room:', roomID);\r\n        if (roomID) {\r\n          const docRef = await db.doc(`room/${roomID}`);\r\n          const doc = await docRef.get();\r\n\r\n          if (doc && doc.exists) {\r\n            console.log('userRef in room:', userRef.id);\r\n            const user = {\r\n              ['user.' +\r\n              userRef.id]: firebase.firestore.Timestamp.now().toDate(),\r\n            };\r\n            console.log('room data:', doc.data());\r\n            console.log('msg queue data:', user);\r\n            await docRef.update(user);\r\n            const updatedDoc = await docRef.get();\r\n            // await db.doc(`room/${roomID}`).onSnapshot(async (doc) => {\r\n            //   const data = doc.data();\r\n            //   const queue = data.userMsgQueue[userRef.id];\r\n\r\n            //   if (queue.length > 0) {\r\n            //     console.log('consuming data:', queue);\r\n            //     const blankQueue = { ['userMsgQueue.' + userRef.id]: [] };\r\n            //     await docRef.update(blankQueue);\r\n            //   }\r\n            // });\r\n\r\n            return updatedDoc.data();\r\n          } else {\r\n            console.log(\"room doesn't exist:\", roomID);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        console.error('join room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    createRoom: async function () {\r\n      try {\r\n        const docRef = await db.collection('room').add({\r\n          user: {},\r\n          created: firebase.firestore.Timestamp.now().toDate(),\r\n        });\r\n        const res = await userRef.update({\r\n          roomOwner: firebase.firestore.FieldValue.arrayUnion(docRef.id),\r\n        });\r\n        console.log('create room id:', docRef.id);\r\n        console.log('create room info:', res);\r\n        return docRef.id;\r\n      } catch (e) {\r\n        console.error('create room exception:', e);\r\n      }\r\n      return null;\r\n    },\r\n    firebaseTimeToTimestamp: firebaseTimeToTimestamp,\r\n  };\r\n};\r\n\r\nconst CALLER_MSG_INITIATE = 'initiate';\r\n\r\nconst CALLEE_MSG_ACCEPT = 'callee-accept';\r\n\r\nconst PEER_STATE_0 = 'not-connected';\r\nconst PEER_STATE_1 = 'initiated';\r\nconst PEER_STATE_2 = 'connecting';\r\nconst PEER_STATE_3 = 'connected';\r\nconst PEER_STATE_4 = 'failed';\r\n\r\nconst PeerInfo = function (id) {\r\n  this.id = id;\r\n  this.state = PEER_STATE_0;\r\n  this.peer = null;\r\n};\r\n\r\n// reference:\r\n// https://ui.dev/react-router-v4-programmatically-navigate/\r\n// const CreateRoom = withRouter(({ ...props }) => {\r\n//   const create = async () => {\r\n//     // const id = uuid();\r\n//     // const roomId = await props.createRoom();\r\n//     // props.history.push(`/room/${roomId}`);\r\n\r\n//     console.log('this is some props -->', props);\r\n//   };\r\n//   return <button onClick={create}>Create room</button>;\r\n// });\r\nconst Video = (props) => {\r\n  const ref = useRef();\r\n\r\n  useEffect(() => {\r\n    props.peer.on('stream', (stream) => {\r\n      console.log('peer stream:', stream);\r\n      ref.current.srcObject = stream;\r\n    });\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <video playsInline autoPlay ref={ref}></video>\r\n    </div>\r\n  );\r\n};\r\nconst Room = withRouter(({ ...props }) => {\r\n  const userVideoRef = useRef();\r\n  const roomID = props.match.params.id;\r\n  const videoConstraints = {\r\n    height: window.innerHeight / 2,\r\n    width: window.innerWidth / 2,\r\n  };\r\n  console.log('roomID-->', roomID, 'props -->', props);\r\n  const userDB = props.userDB;\r\n\r\n  // ==============\r\n  const userInRoomRef = useRef();\r\n  const [userInRoomState, setUserInRoomState] = useState({});\r\n\r\n  useEffect(() => {\r\n    if (userDB === undefined) {\r\n      //return if not initialized\r\n      return;\r\n    }\r\n    if (userInRoomRef.current === undefined) {\r\n      userInRoomRef.current = {};\r\n    }\r\n    navigator.mediaDevices\r\n      .getUserMedia({ video: videoConstraints, audio: false })\r\n      .then(gotMedia);\r\n  }, []);\r\n  const gotMedia = async (stream) => {\r\n    userVideoRef.current.srcObject = stream;\r\n\r\n    const roomInfo = await userDB.joinRoom(roomID);\r\n    if (roomInfo === null) {\r\n      alert('This room does not exist.');\r\n      props.history.push(`/`);\r\n    }\r\n\r\n    //0. initialize list of user in room\r\n    for (const userID in roomInfo.user) {\r\n      if (userID !== userDB.userID()) {\r\n        userInRoomRef.current[userID] = new PeerInfo(userID);\r\n      }\r\n    }\r\n    setUserInRoomState({});\r\n\r\n    //1. register listener to incoming request to connect\r\n    userDB.onCallerMsg(\r\n      roomID,\r\n      'request-connect',\r\n      async (callerPayload, callerMsgInd, callerMsgCnt, from) => {\r\n        while (callerMsgInd < callerMsgCnt) {\r\n          const msg = callerPayload[callerMsgInd++];\r\n\r\n          if (userInRoomRef.current[from] === undefined) {\r\n            userInRoomRef.current[from] = new PeerInfo(from);\r\n          }\r\n          const currentPeerInfo = userInRoomRef.current[from];\r\n\r\n          if (\r\n            currentPeerInfo.state === PEER_STATE_0 &&\r\n            msg === CALLER_MSG_INITIATE\r\n          ) {\r\n            currentPeerInfo.state = PEER_STATE_1;\r\n\r\n            // initiate call\r\n            console.log('initiation recieved from:', from);\r\n            await userDB.sendCallerAResponse(CALLEE_MSG_ACCEPT, from);\r\n          } else if (currentPeerInfo.state === PEER_STATE_1) {\r\n            currentPeerInfo.state = PEER_STATE_2;\r\n\r\n            // process offer\r\n            console.log('recieved offer recieved from:', from);\r\n            console.log('offer:', msg);\r\n            currentPeerInfo.peer = addPeer(msg, from, stream, (signal) => {\r\n              userDB.sendCallerAResponse(signal, from);\r\n            });\r\n            //listen to peer events\r\n            currentPeerInfo.peer.on('connect', () => {\r\n              console.log(\r\n                'connection connected:',\r\n                userInRoomRef.current[from].id\r\n              );\r\n              userInRoomRef.current[from].state = PEER_STATE_3;\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('close', () => {\r\n              userInRoomRef.current[from].state = PEER_STATE_0;\r\n              console.log('connection closed:', userInRoomRef.current[from].id);\r\n\r\n              if (userInRoomRef.current[from].peer) {\r\n                userInRoomRef.current[from].peer.destroy();\r\n                userInRoomRef.current[from].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('error', (err) => {\r\n              console.log(\r\n                'connection error:',\r\n                userInRoomRef.current[from].id,\r\n                err\r\n              );\r\n\r\n              userInRoomRef.current[from].state = PEER_STATE_4;\r\n              if (userInRoomRef.current[from].peer) {\r\n                userInRoomRef.current[from].peer.destroy();\r\n                userInRoomRef.current[from].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n\r\n            // process offer\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else if (\r\n            currentPeerInfo.state === PEER_STATE_2 ||\r\n            currentPeerInfo.state === PEER_STATE_3\r\n          ) {\r\n            // process ICE\r\n            console.log('recieved ICE recieved from:', from);\r\n            console.log('ICE:', msg);\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else {\r\n            // bad state, clean up\r\n            currentPeerInfo.state = PEER_STATE_4;\r\n            if (currentPeerInfo.peer) {\r\n              currentPeerInfo.peer.destroy();\r\n              currentPeerInfo.peer = undefined;\r\n            }\r\n          }\r\n        }\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n    //2. register listener to incoming responses from callee\r\n    userDB.onCalleeMsg(\r\n      roomID,\r\n      'response-signal',\r\n      async (calleePayload, calleeMsgInd, calleeMsgCnt, to) => {\r\n        while (calleeMsgInd < calleeMsgCnt) {\r\n          const msg = calleePayload[calleeMsgInd++];\r\n\r\n          if (userInRoomRef.current[to] === undefined) {\r\n            userInRoomRef.current[to] = new PeerInfo(to);\r\n          }\r\n          const currentPeerInfo = userInRoomRef.current[to];\r\n\r\n          if (\r\n            //callee accepted\r\n            currentPeerInfo.state === PEER_STATE_0 &&\r\n            msg === CALLEE_MSG_ACCEPT\r\n          ) {\r\n            currentPeerInfo.state = PEER_STATE_1;\r\n\r\n            // callee accepted, create and send offer to be sent\r\n            console.log('callee accepted call:', to);\r\n\r\n            currentPeerInfo.peer = createPeer(to, stream, (signal) => {\r\n              userDB.sendCalleeAResponse(signal, to);\r\n            });\r\n\r\n            //listen to peer events\r\n            currentPeerInfo.peer.on('connect', () => {\r\n              userInRoomRef.current[to].state = PEER_STATE_3;\r\n              console.log('connection connect:', userInRoomRef.current[to].id);\r\n\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('close', () => {\r\n              console.log('connection cosed:', userInRoomRef.current[to].id);\r\n\r\n              userInRoomRef.current[to].state = PEER_STATE_0;\r\n              if (userInRoomRef.current[to].peer) {\r\n                userInRoomState[to].peer.destroy();\r\n                userInRoomState[to].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n            currentPeerInfo.peer.on('error', (err) => {\r\n              console.log(\r\n                'connection error:',\r\n                userInRoomRef.current[to].id,\r\n                err\r\n              );\r\n\r\n              userInRoomRef.current[to].state = PEER_STATE_4;\r\n              if (userInRoomRef.currentom[to].peer) {\r\n                userInRoomRef.current[to].peer.destroy();\r\n                userInRoomRef.current[to].peer = undefined;\r\n              }\r\n              setUserInRoomState({});\r\n            });\r\n          } else if (\r\n            currentPeerInfo.state === PEER_STATE_1 ||\r\n            currentPeerInfo.state === PEER_STATE_2 ||\r\n            currentPeerInfo.state === PEER_STATE_3\r\n          ) {\r\n            //process callee accepted and ICE candidate\r\n            if (currentPeerInfo.state === PEER_STATE_1) {\r\n              currentPeerInfo.state = PEER_STATE_2;\r\n            }\r\n\r\n            // process offer\r\n            console.log('recieved answer/ICE recieved from callee:', to);\r\n            console.log('callee data:', msg);\r\n\r\n            // process offer\r\n            currentPeerInfo.peer.signal(msg);\r\n          } else {\r\n            // bad state, clean up\r\n            currentPeerInfo.state = PEER_STATE_4;\r\n            if (currentPeerInfo.peer) {\r\n              currentPeerInfo.peer.destroy();\r\n              currentPeerInfo.peer = undefined;\r\n            }\r\n          }\r\n        }\r\n\r\n        setUserInRoomState({});\r\n      }\r\n    );\r\n\r\n    //3. call existing peers in room\r\n    callPeerInRoom(stream, roomInfo);\r\n  };\r\n  const callPeerInRoom = (stream, roomInfo) => {\r\n    //3. call each user in the roo\r\n    console.log({ roomInfo });\r\n    const userInRoom = roomInfo.user;\r\n    const currentUserID = userDB.userID();\r\n    const joinedTimestamp = userDB.firebaseTimeToTimestamp(\r\n      userInRoom[currentUserID]\r\n    );\r\n    console.log('current user joined room timestamp:', joinedTimestamp);\r\n\r\n    for (const peerID in userInRoom) {\r\n      const timestamp = userDB.firebaseTimeToTimestamp(userInRoom[peerID]);\r\n\r\n      // call users that were on before current user\r\n      if (peerID !== currentUserID && timestamp < joinedTimestamp) {\r\n        callPeer(peerID, stream, roomID);\r\n      }\r\n    }\r\n  };\r\n  const callPeer = (peerID, stream, roomID) => {\r\n    userDB.initiateConnection(roomID, 'initiate-connection', peerID);\r\n  };\r\n  const createPeer = (userToSignal, stream, onSignal) => {\r\n    const peer = new Peer({\r\n      initiator: true,\r\n      trickle: false,\r\n      stream: stream,\r\n    });\r\n    console.log('peer created -->', peer);\r\n    peer.on('signal', (signal) => {\r\n      console.log('signal created for:', userToSignal, signal);\r\n      onSignal(signal);\r\n    });\r\n\r\n    return peer;\r\n  };\r\n  const addPeer = (incomingSignal, callerID, stream, onSignal) => {\r\n    const peer = new Peer({\r\n      initiator: false,\r\n      trickle: false,\r\n      stream,\r\n    });\r\n    peer.on('signal', (signal) => {\r\n      console.log('returning signal created for', callerID, signal);\r\n      onSignal(signal);\r\n    });\r\n    return peer;\r\n  };\r\n\r\n  const peerList = [];\r\n  for (const peerid in userInRoomRef.current) {\r\n    if (userInRoomRef.current[peerid].peer) {\r\n      peerList.push(userInRoomRef.current[peerid].peer);\r\n    }\r\n  }\r\n  const stateToColor = {\r\n    failed: 'red',\r\n    initiated: 'orange',\r\n    'not-connected': 'grey',\r\n    connecting: 'yellow',\r\n    connected: 'green',\r\n  };\r\n\r\n  const stat = !userInRoomRef.current\r\n    ? null\r\n    : Object.keys(userInRoomRef.current).map((key) => {\r\n        return (\r\n          <li key={key}>\r\n            User ID: {key} Status:{' '}\r\n            <span\r\n              style={{\r\n                backgroundColor: stateToColor[userInRoomRef.current[key].state],\r\n              }}\r\n            >\r\n              {userInRoomRef.current[key].state}\r\n            </span>\r\n          </li>\r\n        );\r\n      });\r\n  console.log('peer list:', peerList);\r\n  console.log(userInRoomRef.current);\r\n  return (\r\n    <div>\r\n      <h3>My User ID: {userDB ? userDB.userID() : undefined}</h3>\r\n      <video muted ref={userVideoRef} autoPlay playsInline></video>\r\n      <h3>User In Room:</h3>\r\n      <ul>{stat}</ul>\r\n      <hr></hr>\r\n      {peerList.map((peer, index) => {\r\n        return (\r\n          <div key={index}>\r\n            {index}\r\n            <Video peer={peer}></Video>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n});\r\n\r\nconst App = (props) => {\r\n  const [userDB, setUserDB] = useState();\r\n  const [roomPath, setRoomPath] = useState(null);\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      const userDB = await UserDB();\r\n      setUserDB(userDB);\r\n    })();\r\n  }, []);\r\n\r\n  const createRoom = async () => {\r\n    const roomId = await userDB.createRoom();\r\n    setRoomPath(`/room/${roomId}`);\r\n  };\r\n  return (\r\n    <HashRouter basename='/'>\r\n      <React.StrictMode>\r\n        <button onClick={createRoom}>Create Room</button>\r\n        {roomPath ? <Redirect to={roomPath} /> : undefined}\r\n        <Switch>\r\n          <Route\r\n            path='/room/:id'\r\n            component={() => <Room {...props} userDB={userDB} />}\r\n          ></Route>\r\n        </Switch>\r\n      </React.StrictMode>\r\n    </HashRouter>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}